"""
Init Command - Creates AGENTS.md configuration
Implements three-tier degradation pattern.
"""

import os
import subprocess
from pathlib import Path
from typing import Any, Dict, List

from aget.base import BaseCommand


class InitCommand(BaseCommand):
    """Initialize agent configuration with appropriate tier."""

    def __init__(self):
        """Initialize with template options."""
        super().__init__()

        # Template configurations
        # Note: Using 'workspace' for private and 'products' for public
        # to avoid case sensitivity issues on macOS/Windows
        self.templates = {
            'minimal': {
                'dirs': ['.aget', '.aget/evolution'],
                'description': 'Basic agent configuration'
            },
            'standard': {
                'dirs': ['.aget', '.aget/evolution', 'workspace', 'data'],
                'description': 'Standard workspace with outputs and data'
            },
            'agent': {
                'dirs': [
                    '.aget', '.aget/evolution', '.aget/checkpoints',
                    'src', 'workspace', 'products', 'data',
                    'docs', 'tests'
                ],
                'description': 'Full autonomous agent structure'
            },
            'tool': {
                'dirs': [
                    '.aget', '.aget/evolution',
                    'src', 'products', 'docs', 'tests'
                ],
                'description': 'Tool/library development structure'
            },
            'hybrid': {
                'dirs': [
                    '.aget', '.aget/evolution', '.aget/checkpoints',
                    'src', 'workspace', 'products', 'data',
                    'docs', 'tests', 'examples'
                ],
                'description': 'Combined agent and tool structure'
            }
        }

        self.default_template = """# Agent Configuration

## Project Context
{project_name} - Created with AGET v2 ({template_type} template)

## Session Management Protocols

### Wake Up Protocol
When user says "wake up" or "hey":
- Show current directory and status
- Check git status
- Report readiness

### Wind Down Protocol
When user says "wind down" or "save work":
- Commit changes
- Create session notes
- Show completion

### Sign Off Protocol
When user says "sign off" or "all done":
- Quick save and exit
- No questions

## Directory Structure
{directory_structure}

## Vocabulary Note
- `workspace/` = Your agent's private workspace for exploration
- `products/` = Public products your agent creates/maintains for others
- `src/` = Source code for your agent/tool
- `.aget/evolution/` = Decision and discovery tracking

## Available Patterns
Run `aget list` to see available patterns you can apply.

---
*Generated by AGET v2 - https://github.com/aget-framework/aget*
"""

    def tier_basic(self, **kwargs) -> Dict[str, Any]:
        """
        Basic tier - Create AGENTS.md and directories based on template.
        No external tools required.
        """
        args = kwargs.get('args', [])

        # Determine project path
        project_path = Path.cwd()
        if args and len(args) > 0:
            if args[0] != '.' and not args[0].startswith('--'):
                project_path = Path(args[0])

        # Parse template option
        template_type = 'standard'  # default
        with_patterns = False
        for i, arg in enumerate(args):
            if arg == '--template' and i + 1 < len(args):
                template_type = args[i + 1]
            elif arg == '--with-patterns':
                with_patterns = True

        # Validate template
        if template_type not in self.templates:
            return {
                'success': False,
                'error': f'Invalid template: {template_type}. Options: {", ".join(self.templates.keys())}'
            }

        # Create AGENTS.md
        agents_file = project_path / "AGENTS.md"
        if agents_file.exists() and '--force' not in args:
            return {
                'success': False,
                'error': 'AGENTS.md already exists. Use --force to overwrite.'
            }

        # Create directories based on template
        template_config = self.templates[template_type]
        created_dirs = []
        for dir_path in template_config['dirs']:
            full_path = project_path / dir_path
            full_path.mkdir(parents=True, exist_ok=True)
            created_dirs.append(dir_path)

            # Add README.md to key directories
            readme_content = self._get_readme_content(dir_path)
            if readme_content:
                readme_file = full_path / "README.md"
                if not readme_file.exists():
                    readme_file.write_text(readme_content)

        # Generate directory structure documentation
        directory_docs = self._generate_directory_docs(template_type)

        # Write AGENTS.md
        content = self.default_template.format(
            project_name=project_path.name,
            template_type=template_type,
            directory_structure=directory_docs
        )
        agents_file.write_text(content)

        # Create version tracking
        aget_dir = project_path / ".aget"
        version_file = aget_dir / "version.json"
        version_data = {
            "aget_version": "2.0.0-alpha",
            "created": "2025-09-24",
            "template": template_type,
            "tier": "basic"
        }
        import json
        version_file.write_text(json.dumps(version_data, indent=2))

        # Create CLAUDE.md symlink for backward compatibility
        claude_file = project_path / "CLAUDE.md"
        if not claude_file.exists():
            try:
                claude_file.symlink_to("AGENTS.md")
            except OSError:
                # Windows might not support symlinks
                claude_file.write_text(
                    "# This file redirects to AGENTS.md\n"
                    "Please see AGENTS.md for agent configuration.\n"
                )

        # Apply patterns if requested
        patterns_applied = []
        if with_patterns:
            # Import apply command
            from aget.config.commands.apply import ApplyCommand
            apply_cmd = ApplyCommand()

            # Determine which patterns to apply based on template
            patterns_to_apply = self._get_patterns_for_template(template_type)

            for pattern in patterns_to_apply:
                # Call tier_basic directly with kwargs
                result = apply_cmd.tier_basic(args=[pattern])
                if result.get('success'):
                    patterns_applied.append(pattern)

        message = f'Created {template_type} template in {project_path}'
        if patterns_applied:
            message += f' with {len(patterns_applied)} patterns applied'

        return {
            'success': True,
            'message': message,
            'template': template_type,
            'description': template_config['description'],
            'files_created': ['AGENTS.md', 'CLAUDE.md'] + created_dirs,
            'patterns_applied': patterns_applied if with_patterns else []
        }

    def _get_patterns_for_template(self, template_type: str) -> List[str]:
        """Get list of patterns to apply for each template type."""
        pattern_map = {
            'minimal': ['session/wake'],
            'standard': ['session/wake', 'session/wind_down', 'housekeeping/cleanup'],
            'agent': [
                'session/wake', 'session/wind_down', 'session/sign_off',
                'housekeeping/cleanup', 'housekeeping/sanity_check'
            ],
            'tool': ['session/wake', 'housekeeping/cleanup'],
            'hybrid': [
                'session/wake', 'session/wind_down', 'session/sign_off',
                'housekeeping/cleanup', 'housekeeping/sanity_check'
            ]
        }
        return pattern_map.get(template_type, [])

    def _get_readme_content(self, dir_path: str) -> str:
        """Generate README content for specific directories."""
        readmes = {
            'workspace': """# Workspace Directory

This is your agent's private workspace for exploration and experimentation.

## Purpose
- Internal tools and scripts
- Work-in-progress code
- Experimental features
- Private explorations

## Note
Content here is NOT intended for public use. When ready to share,
use `aget extract` to move to products/ directory.
""",
            'products': """# Products Directory (Public)

This directory contains public products created and maintained by the agent.

## Purpose
- Standalone tools ready for public use
- Extracted and sanitized utilities
- Documentation and examples
- Published packages

## Publishing
Use `aget extract --from workspace/ --to products/` to promote internal
tools to public products.
""",
            'src': """# Source Code

Main source code for this project.

## Structure
Organize by functionality or component as appropriate for your project.
""",
            '.aget/evolution': """# Evolution Tracking

This directory captures the agent's decision-making process and discoveries.

## Entry Types
- **decisions/** - Architectural and design decisions
- **discoveries/** - Patterns and insights found
- **extractions/** - Records of outputsâ†’Outputs promotions

## Usage
Use `aget evolution --type <type>` to add entries.
""",
            'data': """# Data Directory

Persistent data storage for the agent.

## Usage
- Configuration files
- Cached data
- Training data
- Results and metrics
""",
            'tests': """# Tests Directory

Test suite for this project.

## Running Tests
```bash
python -m pytest tests/
```
""",
            'docs': """# Documentation

Project documentation and guides.

## Contents
- Architecture documentation
- API references
- User guides
- Development notes
""",
            'examples': """# Examples

Example usage and demonstrations.

## Purpose
- Show how to use the tools/agent
- Provide templates for common tasks
- Demonstrate best practices
"""
        }

        # Return content if we have it, otherwise None
        return readmes.get(dir_path)

    def _generate_directory_docs(self, template_type: str) -> str:
        """Generate directory structure documentation for AGENTS.md."""
        docs = {
            'minimal': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking""",

            'standard': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `workspace/` - Agent's internal workspace (private explorations)
- `data/` - Persistent data storage""",

            'agent': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `.aget/checkpoints/` - Agent state checkpoints
- `src/` - Agent source code
- `workspace/` - Internal workspace for explorations
- `products/` - Public products the agent maintains
- `data/` - Persistent data storage
- `docs/` - Documentation
- `tests/` - Test suite""",

            'tool': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `src/` - Tool source code
- `products/` - Public tool/library
- `docs/` - Documentation
- `tests/` - Test suite""",

            'hybrid': """- `.aget/` - Framework metadata and configuration
- `.aget/evolution/` - Decision and discovery tracking
- `.aget/checkpoints/` - Agent state checkpoints
- `src/` - Source code for agent and tools
- `workspace/` - Internal workspace for explorations
- `products/` - Public products maintained
- `data/` - Persistent data storage
- `docs/` - Documentation
- `tests/` - Test suite
- `examples/` - Usage examples"""
        }

        return docs.get(template_type, docs['standard'])

    def tier_git(self, **kwargs) -> Dict[str, Any]:
        """
        Git tier - Also update .gitignore.
        """
        # First do everything basic tier does
        result = self.tier_basic(**kwargs)
        if not result['success']:
            return result

        args = kwargs.get('args', [])
        project_path = Path.cwd()
        if args and len(args) > 0 and args[0] != '.' and not args[0].startswith('--'):
            project_path = Path(args[0])

        # Get template type to add appropriate ignores
        template_type = result.get('template', 'standard')

        # Update .gitignore
        gitignore = project_path / ".gitignore"
        ignore_lines = [
            "# AGET files",
            ".aget/backups/",
            ".aget/cache/",
            ".aget/checkpoints/",
            ".session_state.json",
            "",
            "# Python",
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            ".pytest_cache/",
            "",
            "# Environment",
            ".env",
            "venv/",
            "env/",
        ]

        # Add template-specific ignores
        if template_type in ['agent', 'hybrid']:
            ignore_lines.extend([
                "",
                "# Agent workspace",
                "workspace/.tmp/",
                "workspace/*.log",
                "workspace/__pycache__/",
            ])

        if gitignore.exists():
            content = gitignore.read_text()
            for line in ignore_lines:
                if line and line not in content:
                    content += f"\n{line}"
            gitignore.write_text(content)
        else:
            gitignore.write_text("\n".join(ignore_lines) + "\n")

        result['files_created'].append('.gitignore')
        result['message'] += ' (git tier: updated .gitignore)'

        # Check if in git repo
        try:
            subprocess.run(
                ['git', 'rev-parse', '--git-dir'],
                cwd=project_path,
                capture_output=True,
                check=True,
                timeout=1
            )
            result['git_repo'] = True
        except:
            result['git_repo'] = False
            result['note'] = 'Not a git repository. Run `git init` to enable version control.'

        return result

    def tier_gh(self, **kwargs) -> Dict[str, Any]:
        """
        GitHub CLI tier - Also create issue templates.
        """
        # First do everything git tier does
        result = self.tier_git(**kwargs)
        if not result['success']:
            return result

        args = kwargs.get('args', [])
        project_path = Path.cwd()
        if args and len(args) > 0 and args[0] != '.' and not args[0].startswith('--'):
            project_path = Path(args[0])

        # Create .github/ISSUE_TEMPLATE for agent error reporting
        github_dir = project_path / ".github" / "ISSUE_TEMPLATE"
        github_dir.mkdir(parents=True, exist_ok=True)

        # Create agent error template
        agent_template = github_dir / "agent-error.yml"
        template_content = """name: Agent Error Report
description: Report an error encountered by an AI agent
title: "[Agent Error]: "
labels: ["agent-reported", "needs-triage"]
body:
  - type: dropdown
    id: agent_type
    attributes:
      label: Agent Type
      options:
        - Claude Code
        - Cursor
        - Aider
        - Windsurf
        - Other
    validations:
      required: true

  - type: textarea
    id: error_description
    attributes:
      label: Error Description
      description: What went wrong?
    validations:
      required: true

  - type: textarea
    id: context
    attributes:
      label: Context
      description: What was the agent trying to do?
    validations:
      required: true

  - type: textarea
    id: stack_trace
    attributes:
      label: Error Output
      description: Any error messages or stack traces
      render: shell
"""
        agent_template.write_text(template_content)

        result['files_created'].extend([
            '.github/ISSUE_TEMPLATE/',
            '.github/ISSUE_TEMPLATE/agent-error.yml'
        ])
        result['message'] += ' (gh tier: created issue templates)'

        # Check if gh is authenticated
        try:
            gh_check = subprocess.run(
                ['gh', 'auth', 'status'],
                capture_output=True,
                timeout=1
            )
            if gh_check.returncode == 0:
                result['gh_ready'] = True
            else:
                result['gh_ready'] = False
                result['gh_note'] = 'Run `gh auth login` to enable GitHub features'
        except:
            result['gh_ready'] = False

        return result